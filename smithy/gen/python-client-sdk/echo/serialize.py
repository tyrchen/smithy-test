# Code generated by smithy-python-codegen DO NOT EDIT.

import json
from typing import AsyncIterable
from urllib.parse import quote as urlquote

from smithy_python._private import Field, Fields, URI as _URI
from smithy_python._private.http import HTTPRequest as _HTTPRequest
from smithy_python.httputils import join_query_params
from smithy_python.interfaces.blobs import AsyncBytesReader
from smithy_python.interfaces.http import HTTPRequest
from smithy_python.types import Document

from .config import Config
from .errors import ServiceError
from .models import (
    CreateTodoInput,
    DeleteTodoInput,
    EchoMessageInput,
    GetTodoInput,
    ListTodosInput,
    SigninInput,
    UpdateTodoInput,
    UpdateTodoStatusInput,
)


async def _serialize_create_todo(input: CreateTodoInput, config: Config) -> HTTPRequest:
    path = "/todos"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, Document] = {}

    if input.title is not None:
        result["title"] = input.title

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_delete_todo(input: DeleteTodoInput, config: Config) -> HTTPRequest:
    if not input.id:
        raise ServiceError("id must not be empty.")

    path = "/todos/{id}".format(
        id=urlquote(input.id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="DELETE",
        fields=headers,
        body=body,
    )


async def _serialize_echo_message(
    input: EchoMessageInput, config: Config
) -> HTTPRequest:
    path = "/echo"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.message:
        headers.extend(Fields([Field(name="x-echo-message", values=[input.message])]))
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_get_todo(input: GetTodoInput, config: Config) -> HTTPRequest:
    if not input.id:
        raise ServiceError("id must not be empty.")

    path = "/todos/{id}".format(
        id=urlquote(input.id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_list_todos(input: ListTodosInput, config: Config) -> HTTPRequest:
    path = "/todos"
    query: str = f""

    query_params: list[tuple[str, str | None]] = []
    if input.next_token is not None:
        query_params.append(("nextToken", input.next_token))
    if input.size is not None:
        query_params.append(("size", str(input.size)))

    query = join_query_params(params=query_params, prefix=query)

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="GET",
        fields=headers,
        body=body,
    )


async def _serialize_signin(input: SigninInput, config: Config) -> HTTPRequest:
    path = "/signin"
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, Document] = {}

    if input.password is not None:
        result["password"] = input.password

    if input.username is not None:
        result["username"] = input.username

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="POST",
        fields=headers,
        body=body,
    )


async def _serialize_update_todo(input: UpdateTodoInput, config: Config) -> HTTPRequest:
    if not input.id:
        raise ServiceError("id must not be empty.")

    path = "/todos/{id}".format(
        id=urlquote(input.id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    result: dict[str, Document] = {}

    if input.title is not None:
        result["title"] = input.title

    content = json.dumps(result).encode("utf-8")
    content_length = len(content)
    body = AsyncBytesReader(content)

    headers = Fields(
        [
            Field(name="Content-Type", values=["application/json"]),
            Field(name="Content-Length", values=[str(content_length)]),
        ]
    )

    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )


async def _serialize_update_todo_status(
    input: UpdateTodoStatusInput, config: Config
) -> HTTPRequest:
    if not input.id:
        raise ServiceError("id must not be empty.")

    path = "/todos/{id}/status".format(
        id=urlquote(input.id, safe=""),
    )
    query: str = f""

    body: AsyncIterable[bytes] = AsyncBytesReader(b"")
    headers = Fields([])

    if input.status is not None:
        headers.extend(
            Fields(
                [
                    Field(
                        name="X-Todo-Status",
                        values=[("true" if input.status else "false")],
                    )
                ]
            )
        )
    return _HTTPRequest(
        destination=_URI(
            host="",
            path=path,
            scheme="https",
            query=query,
        ),
        method="PUT",
        fields=headers,
        body=body,
    )
