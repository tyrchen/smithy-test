// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// The service builder for [`EchoService`].
///
/// Constructed via [`EchoService::builder`].
pub struct EchoServiceBuilder<Body, L, HttpPl, ModelPl> {
    create_todo: Option<::aws_smithy_http_server::routing::Route<Body>>,
    delete_todo: Option<::aws_smithy_http_server::routing::Route<Body>>,
    echo_message: Option<::aws_smithy_http_server::routing::Route<Body>>,
    get_todo: Option<::aws_smithy_http_server::routing::Route<Body>>,
    list_todos: Option<::aws_smithy_http_server::routing::Route<Body>>,
    signin: Option<::aws_smithy_http_server::routing::Route<Body>>,
    update_todo: Option<::aws_smithy_http_server::routing::Route<Body>>,
    update_todo_status: Option<::aws_smithy_http_server::routing::Route<Body>>,
    layer: L,
    http_plugin: HttpPl,
    model_plugin: ModelPl,
}

impl<Body, L, HttpPl, ModelPl> EchoServiceBuilder<Body, L, HttpPl, ModelPl> {
    /// Sets the [`CreateTodo`](crate::operation_shape::CreateTodo) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](::aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](::aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use echo_server_sdk::{EchoService, EchoServiceConfig};
    ///
    /// use echo_server_sdk::{input, output, error};
    ///
    /// async fn handler(input: input::CreateTodoInput) -> Result<output::CreateTodoOutput, error::CreateTodoError> {
    ///     todo!()
    /// }
    ///
    /// let config = EchoServiceConfig::builder().build();
    /// let app = EchoService::builder(config)
    ///     .create_todo(handler)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: EchoService<::aws_smithy_http_server::routing::RoutingService<::aws_smithy_http_server::protocol::rest::router::RestRouter<::aws_smithy_http_server::routing::Route>, ::aws_smithy_http_server::protocol::rest_json_1::RestJson1>> = app;
    /// ```
    ///
                    pub fn create_todo<HandlerType, HandlerExtractors, UpgradeExtractors>(self, handler: HandlerType) -> Self
                    where
                        HandlerType: ::aws_smithy_http_server::operation::Handler<crate::operation_shape::CreateTodo, HandlerExtractors>,

                        ModelPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::CreateTodo,
                            ::aws_smithy_http_server::operation::IntoService<crate::operation_shape::CreateTodo, HandlerType>
                        >,
                        ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::CreateTodo,
                            ModelPl::Output
                        >,
                        HttpPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::CreateTodo,
                            <
                                ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>
                                as ::aws_smithy_http_server::plugin::Plugin<
                                    EchoService<L>,
                                    crate::operation_shape::CreateTodo,
                                    ModelPl::Output
                                >
                            >::Output
                        >,

                        HttpPl::Output: ::tower::Service<::http::Request<Body>, Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>, Error = ::std::convert::Infallible> + Clone + Send + 'static,
                        <HttpPl::Output as ::tower::Service<::http::Request<Body>>>::Future: Send + 'static,

                    {
        use ::aws_smithy_http_server::operation::OperationShapeExt;
        use ::aws_smithy_http_server::plugin::Plugin;
        let svc = crate::operation_shape::CreateTodo::from_handler(handler);
        let svc = self.model_plugin.apply(svc);
        let svc = ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.create_todo_custom(svc)
    }

    /// Sets the [`CreateTodo`](crate::operation_shape::CreateTodo) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](::aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](::aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use echo_server_sdk::{EchoService, EchoServiceConfig};
    ///
    /// use echo_server_sdk::{input, output, error};
    ///
    /// async fn handler(input: input::CreateTodoInput) -> Result<output::CreateTodoOutput, error::CreateTodoError> {
    ///     todo!()
    /// }
    ///
    /// let config = EchoServiceConfig::builder().build();
    /// let svc = ::tower::util::service_fn(handler);
    /// let app = EchoService::builder(config)
    ///     .create_todo_service(svc)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: EchoService<::aws_smithy_http_server::routing::RoutingService<::aws_smithy_http_server::protocol::rest::router::RestRouter<::aws_smithy_http_server::routing::Route>, ::aws_smithy_http_server::protocol::rest_json_1::RestJson1>> = app;
    /// ```
    ///
                    pub fn create_todo_service<S, ServiceExtractors, UpgradeExtractors>(self, service: S) -> Self
                    where
                        S: ::aws_smithy_http_server::operation::OperationService<crate::operation_shape::CreateTodo, ServiceExtractors>,

                        ModelPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::CreateTodo,
                            ::aws_smithy_http_server::operation::Normalize<crate::operation_shape::CreateTodo, S>
                        >,
                        ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::CreateTodo,
                            ModelPl::Output
                        >,
                        HttpPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::CreateTodo,
                            <
                                ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>
                                as ::aws_smithy_http_server::plugin::Plugin<
                                    EchoService<L>,
                                    crate::operation_shape::CreateTodo,
                                    ModelPl::Output
                                >
                            >::Output
                        >,

                        HttpPl::Output: ::tower::Service<::http::Request<Body>, Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>, Error = ::std::convert::Infallible> + Clone + Send + 'static,
                        <HttpPl::Output as ::tower::Service<::http::Request<Body>>>::Future: Send + 'static,

                    {
        use ::aws_smithy_http_server::operation::OperationShapeExt;
        use ::aws_smithy_http_server::plugin::Plugin;
        let svc = crate::operation_shape::CreateTodo::from_service(service);
        let svc = self.model_plugin.apply(svc);
        let svc = ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.create_todo_custom(svc)
    }

    /// Sets the [`CreateTodo`](crate::operation_shape::CreateTodo) to a custom [`Service`](tower::Service).
    /// not constrained by the Smithy contract.
    fn create_todo_custom<S>(mut self, svc: S) -> Self
    where
        S: ::tower::Service<
                ::http::Request<Body>,
                Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>,
                Error = ::std::convert::Infallible,
            > + Clone
            + Send
            + 'static,
        S::Future: Send + 'static,
    {
        self.create_todo = Some(::aws_smithy_http_server::routing::Route::new(svc));
        self
    }

    /// Sets the [`DeleteTodo`](crate::operation_shape::DeleteTodo) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](::aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](::aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use echo_server_sdk::{EchoService, EchoServiceConfig};
    ///
    /// use echo_server_sdk::{input, output, error};
    ///
    /// async fn handler(input: input::DeleteTodoInput) -> Result<output::DeleteTodoOutput, error::DeleteTodoError> {
    ///     todo!()
    /// }
    ///
    /// let config = EchoServiceConfig::builder().build();
    /// let app = EchoService::builder(config)
    ///     .delete_todo(handler)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: EchoService<::aws_smithy_http_server::routing::RoutingService<::aws_smithy_http_server::protocol::rest::router::RestRouter<::aws_smithy_http_server::routing::Route>, ::aws_smithy_http_server::protocol::rest_json_1::RestJson1>> = app;
    /// ```
    ///
                    pub fn delete_todo<HandlerType, HandlerExtractors, UpgradeExtractors>(self, handler: HandlerType) -> Self
                    where
                        HandlerType: ::aws_smithy_http_server::operation::Handler<crate::operation_shape::DeleteTodo, HandlerExtractors>,

                        ModelPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::DeleteTodo,
                            ::aws_smithy_http_server::operation::IntoService<crate::operation_shape::DeleteTodo, HandlerType>
                        >,
                        ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::DeleteTodo,
                            ModelPl::Output
                        >,
                        HttpPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::DeleteTodo,
                            <
                                ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>
                                as ::aws_smithy_http_server::plugin::Plugin<
                                    EchoService<L>,
                                    crate::operation_shape::DeleteTodo,
                                    ModelPl::Output
                                >
                            >::Output
                        >,

                        HttpPl::Output: ::tower::Service<::http::Request<Body>, Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>, Error = ::std::convert::Infallible> + Clone + Send + 'static,
                        <HttpPl::Output as ::tower::Service<::http::Request<Body>>>::Future: Send + 'static,

                    {
        use ::aws_smithy_http_server::operation::OperationShapeExt;
        use ::aws_smithy_http_server::plugin::Plugin;
        let svc = crate::operation_shape::DeleteTodo::from_handler(handler);
        let svc = self.model_plugin.apply(svc);
        let svc = ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.delete_todo_custom(svc)
    }

    /// Sets the [`DeleteTodo`](crate::operation_shape::DeleteTodo) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](::aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](::aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use echo_server_sdk::{EchoService, EchoServiceConfig};
    ///
    /// use echo_server_sdk::{input, output, error};
    ///
    /// async fn handler(input: input::DeleteTodoInput) -> Result<output::DeleteTodoOutput, error::DeleteTodoError> {
    ///     todo!()
    /// }
    ///
    /// let config = EchoServiceConfig::builder().build();
    /// let svc = ::tower::util::service_fn(handler);
    /// let app = EchoService::builder(config)
    ///     .delete_todo_service(svc)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: EchoService<::aws_smithy_http_server::routing::RoutingService<::aws_smithy_http_server::protocol::rest::router::RestRouter<::aws_smithy_http_server::routing::Route>, ::aws_smithy_http_server::protocol::rest_json_1::RestJson1>> = app;
    /// ```
    ///
                    pub fn delete_todo_service<S, ServiceExtractors, UpgradeExtractors>(self, service: S) -> Self
                    where
                        S: ::aws_smithy_http_server::operation::OperationService<crate::operation_shape::DeleteTodo, ServiceExtractors>,

                        ModelPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::DeleteTodo,
                            ::aws_smithy_http_server::operation::Normalize<crate::operation_shape::DeleteTodo, S>
                        >,
                        ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::DeleteTodo,
                            ModelPl::Output
                        >,
                        HttpPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::DeleteTodo,
                            <
                                ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>
                                as ::aws_smithy_http_server::plugin::Plugin<
                                    EchoService<L>,
                                    crate::operation_shape::DeleteTodo,
                                    ModelPl::Output
                                >
                            >::Output
                        >,

                        HttpPl::Output: ::tower::Service<::http::Request<Body>, Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>, Error = ::std::convert::Infallible> + Clone + Send + 'static,
                        <HttpPl::Output as ::tower::Service<::http::Request<Body>>>::Future: Send + 'static,

                    {
        use ::aws_smithy_http_server::operation::OperationShapeExt;
        use ::aws_smithy_http_server::plugin::Plugin;
        let svc = crate::operation_shape::DeleteTodo::from_service(service);
        let svc = self.model_plugin.apply(svc);
        let svc = ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.delete_todo_custom(svc)
    }

    /// Sets the [`DeleteTodo`](crate::operation_shape::DeleteTodo) to a custom [`Service`](tower::Service).
    /// not constrained by the Smithy contract.
    fn delete_todo_custom<S>(mut self, svc: S) -> Self
    where
        S: ::tower::Service<
                ::http::Request<Body>,
                Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>,
                Error = ::std::convert::Infallible,
            > + Clone
            + Send
            + 'static,
        S::Future: Send + 'static,
    {
        self.delete_todo = Some(::aws_smithy_http_server::routing::Route::new(svc));
        self
    }

    /// Sets the [`EchoMessage`](crate::operation_shape::EchoMessage) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](::aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](::aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use echo_server_sdk::{EchoService, EchoServiceConfig};
    ///
    /// use echo_server_sdk::{input, output, error};
    ///
    /// async fn handler(input: input::EchoMessageInput) -> Result<output::EchoMessageOutput, error::EchoMessageError> {
    ///     todo!()
    /// }
    ///
    /// let config = EchoServiceConfig::builder().build();
    /// let app = EchoService::builder(config)
    ///     .echo_message(handler)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: EchoService<::aws_smithy_http_server::routing::RoutingService<::aws_smithy_http_server::protocol::rest::router::RestRouter<::aws_smithy_http_server::routing::Route>, ::aws_smithy_http_server::protocol::rest_json_1::RestJson1>> = app;
    /// ```
    ///
                    pub fn echo_message<HandlerType, HandlerExtractors, UpgradeExtractors>(self, handler: HandlerType) -> Self
                    where
                        HandlerType: ::aws_smithy_http_server::operation::Handler<crate::operation_shape::EchoMessage, HandlerExtractors>,

                        ModelPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::EchoMessage,
                            ::aws_smithy_http_server::operation::IntoService<crate::operation_shape::EchoMessage, HandlerType>
                        >,
                        ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::EchoMessage,
                            ModelPl::Output
                        >,
                        HttpPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::EchoMessage,
                            <
                                ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>
                                as ::aws_smithy_http_server::plugin::Plugin<
                                    EchoService<L>,
                                    crate::operation_shape::EchoMessage,
                                    ModelPl::Output
                                >
                            >::Output
                        >,

                        HttpPl::Output: ::tower::Service<::http::Request<Body>, Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>, Error = ::std::convert::Infallible> + Clone + Send + 'static,
                        <HttpPl::Output as ::tower::Service<::http::Request<Body>>>::Future: Send + 'static,

                    {
        use ::aws_smithy_http_server::operation::OperationShapeExt;
        use ::aws_smithy_http_server::plugin::Plugin;
        let svc = crate::operation_shape::EchoMessage::from_handler(handler);
        let svc = self.model_plugin.apply(svc);
        let svc = ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.echo_message_custom(svc)
    }

    /// Sets the [`EchoMessage`](crate::operation_shape::EchoMessage) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](::aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](::aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use echo_server_sdk::{EchoService, EchoServiceConfig};
    ///
    /// use echo_server_sdk::{input, output, error};
    ///
    /// async fn handler(input: input::EchoMessageInput) -> Result<output::EchoMessageOutput, error::EchoMessageError> {
    ///     todo!()
    /// }
    ///
    /// let config = EchoServiceConfig::builder().build();
    /// let svc = ::tower::util::service_fn(handler);
    /// let app = EchoService::builder(config)
    ///     .echo_message_service(svc)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: EchoService<::aws_smithy_http_server::routing::RoutingService<::aws_smithy_http_server::protocol::rest::router::RestRouter<::aws_smithy_http_server::routing::Route>, ::aws_smithy_http_server::protocol::rest_json_1::RestJson1>> = app;
    /// ```
    ///
                    pub fn echo_message_service<S, ServiceExtractors, UpgradeExtractors>(self, service: S) -> Self
                    where
                        S: ::aws_smithy_http_server::operation::OperationService<crate::operation_shape::EchoMessage, ServiceExtractors>,

                        ModelPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::EchoMessage,
                            ::aws_smithy_http_server::operation::Normalize<crate::operation_shape::EchoMessage, S>
                        >,
                        ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::EchoMessage,
                            ModelPl::Output
                        >,
                        HttpPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::EchoMessage,
                            <
                                ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>
                                as ::aws_smithy_http_server::plugin::Plugin<
                                    EchoService<L>,
                                    crate::operation_shape::EchoMessage,
                                    ModelPl::Output
                                >
                            >::Output
                        >,

                        HttpPl::Output: ::tower::Service<::http::Request<Body>, Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>, Error = ::std::convert::Infallible> + Clone + Send + 'static,
                        <HttpPl::Output as ::tower::Service<::http::Request<Body>>>::Future: Send + 'static,

                    {
        use ::aws_smithy_http_server::operation::OperationShapeExt;
        use ::aws_smithy_http_server::plugin::Plugin;
        let svc = crate::operation_shape::EchoMessage::from_service(service);
        let svc = self.model_plugin.apply(svc);
        let svc = ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.echo_message_custom(svc)
    }

    /// Sets the [`EchoMessage`](crate::operation_shape::EchoMessage) to a custom [`Service`](tower::Service).
    /// not constrained by the Smithy contract.
    fn echo_message_custom<S>(mut self, svc: S) -> Self
    where
        S: ::tower::Service<
                ::http::Request<Body>,
                Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>,
                Error = ::std::convert::Infallible,
            > + Clone
            + Send
            + 'static,
        S::Future: Send + 'static,
    {
        self.echo_message = Some(::aws_smithy_http_server::routing::Route::new(svc));
        self
    }

    /// Sets the [`GetTodo`](crate::operation_shape::GetTodo) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](::aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](::aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use echo_server_sdk::{EchoService, EchoServiceConfig};
    ///
    /// use echo_server_sdk::{input, output, error};
    ///
    /// async fn handler(input: input::GetTodoInput) -> Result<output::GetTodoOutput, error::GetTodoError> {
    ///     todo!()
    /// }
    ///
    /// let config = EchoServiceConfig::builder().build();
    /// let app = EchoService::builder(config)
    ///     .get_todo(handler)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: EchoService<::aws_smithy_http_server::routing::RoutingService<::aws_smithy_http_server::protocol::rest::router::RestRouter<::aws_smithy_http_server::routing::Route>, ::aws_smithy_http_server::protocol::rest_json_1::RestJson1>> = app;
    /// ```
    ///
                    pub fn get_todo<HandlerType, HandlerExtractors, UpgradeExtractors>(self, handler: HandlerType) -> Self
                    where
                        HandlerType: ::aws_smithy_http_server::operation::Handler<crate::operation_shape::GetTodo, HandlerExtractors>,

                        ModelPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::GetTodo,
                            ::aws_smithy_http_server::operation::IntoService<crate::operation_shape::GetTodo, HandlerType>
                        >,
                        ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::GetTodo,
                            ModelPl::Output
                        >,
                        HttpPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::GetTodo,
                            <
                                ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>
                                as ::aws_smithy_http_server::plugin::Plugin<
                                    EchoService<L>,
                                    crate::operation_shape::GetTodo,
                                    ModelPl::Output
                                >
                            >::Output
                        >,

                        HttpPl::Output: ::tower::Service<::http::Request<Body>, Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>, Error = ::std::convert::Infallible> + Clone + Send + 'static,
                        <HttpPl::Output as ::tower::Service<::http::Request<Body>>>::Future: Send + 'static,

                    {
        use ::aws_smithy_http_server::operation::OperationShapeExt;
        use ::aws_smithy_http_server::plugin::Plugin;
        let svc = crate::operation_shape::GetTodo::from_handler(handler);
        let svc = self.model_plugin.apply(svc);
        let svc = ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.get_todo_custom(svc)
    }

    /// Sets the [`GetTodo`](crate::operation_shape::GetTodo) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](::aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](::aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use echo_server_sdk::{EchoService, EchoServiceConfig};
    ///
    /// use echo_server_sdk::{input, output, error};
    ///
    /// async fn handler(input: input::GetTodoInput) -> Result<output::GetTodoOutput, error::GetTodoError> {
    ///     todo!()
    /// }
    ///
    /// let config = EchoServiceConfig::builder().build();
    /// let svc = ::tower::util::service_fn(handler);
    /// let app = EchoService::builder(config)
    ///     .get_todo_service(svc)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: EchoService<::aws_smithy_http_server::routing::RoutingService<::aws_smithy_http_server::protocol::rest::router::RestRouter<::aws_smithy_http_server::routing::Route>, ::aws_smithy_http_server::protocol::rest_json_1::RestJson1>> = app;
    /// ```
    ///
                    pub fn get_todo_service<S, ServiceExtractors, UpgradeExtractors>(self, service: S) -> Self
                    where
                        S: ::aws_smithy_http_server::operation::OperationService<crate::operation_shape::GetTodo, ServiceExtractors>,

                        ModelPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::GetTodo,
                            ::aws_smithy_http_server::operation::Normalize<crate::operation_shape::GetTodo, S>
                        >,
                        ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::GetTodo,
                            ModelPl::Output
                        >,
                        HttpPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::GetTodo,
                            <
                                ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>
                                as ::aws_smithy_http_server::plugin::Plugin<
                                    EchoService<L>,
                                    crate::operation_shape::GetTodo,
                                    ModelPl::Output
                                >
                            >::Output
                        >,

                        HttpPl::Output: ::tower::Service<::http::Request<Body>, Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>, Error = ::std::convert::Infallible> + Clone + Send + 'static,
                        <HttpPl::Output as ::tower::Service<::http::Request<Body>>>::Future: Send + 'static,

                    {
        use ::aws_smithy_http_server::operation::OperationShapeExt;
        use ::aws_smithy_http_server::plugin::Plugin;
        let svc = crate::operation_shape::GetTodo::from_service(service);
        let svc = self.model_plugin.apply(svc);
        let svc = ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.get_todo_custom(svc)
    }

    /// Sets the [`GetTodo`](crate::operation_shape::GetTodo) to a custom [`Service`](tower::Service).
    /// not constrained by the Smithy contract.
    fn get_todo_custom<S>(mut self, svc: S) -> Self
    where
        S: ::tower::Service<
                ::http::Request<Body>,
                Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>,
                Error = ::std::convert::Infallible,
            > + Clone
            + Send
            + 'static,
        S::Future: Send + 'static,
    {
        self.get_todo = Some(::aws_smithy_http_server::routing::Route::new(svc));
        self
    }

    /// Sets the [`ListTodos`](crate::operation_shape::ListTodos) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](::aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](::aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use echo_server_sdk::{EchoService, EchoServiceConfig};
    ///
    /// use echo_server_sdk::{input, output, error};
    ///
    /// async fn handler(input: input::ListTodosInput) -> Result<output::ListTodosOutput, error::ListTodosError> {
    ///     todo!()
    /// }
    ///
    /// let config = EchoServiceConfig::builder().build();
    /// let app = EchoService::builder(config)
    ///     .list_todos(handler)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: EchoService<::aws_smithy_http_server::routing::RoutingService<::aws_smithy_http_server::protocol::rest::router::RestRouter<::aws_smithy_http_server::routing::Route>, ::aws_smithy_http_server::protocol::rest_json_1::RestJson1>> = app;
    /// ```
    ///
                    pub fn list_todos<HandlerType, HandlerExtractors, UpgradeExtractors>(self, handler: HandlerType) -> Self
                    where
                        HandlerType: ::aws_smithy_http_server::operation::Handler<crate::operation_shape::ListTodos, HandlerExtractors>,

                        ModelPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::ListTodos,
                            ::aws_smithy_http_server::operation::IntoService<crate::operation_shape::ListTodos, HandlerType>
                        >,
                        ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::ListTodos,
                            ModelPl::Output
                        >,
                        HttpPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::ListTodos,
                            <
                                ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>
                                as ::aws_smithy_http_server::plugin::Plugin<
                                    EchoService<L>,
                                    crate::operation_shape::ListTodos,
                                    ModelPl::Output
                                >
                            >::Output
                        >,

                        HttpPl::Output: ::tower::Service<::http::Request<Body>, Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>, Error = ::std::convert::Infallible> + Clone + Send + 'static,
                        <HttpPl::Output as ::tower::Service<::http::Request<Body>>>::Future: Send + 'static,

                    {
        use ::aws_smithy_http_server::operation::OperationShapeExt;
        use ::aws_smithy_http_server::plugin::Plugin;
        let svc = crate::operation_shape::ListTodos::from_handler(handler);
        let svc = self.model_plugin.apply(svc);
        let svc = ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.list_todos_custom(svc)
    }

    /// Sets the [`ListTodos`](crate::operation_shape::ListTodos) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](::aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](::aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use echo_server_sdk::{EchoService, EchoServiceConfig};
    ///
    /// use echo_server_sdk::{input, output, error};
    ///
    /// async fn handler(input: input::ListTodosInput) -> Result<output::ListTodosOutput, error::ListTodosError> {
    ///     todo!()
    /// }
    ///
    /// let config = EchoServiceConfig::builder().build();
    /// let svc = ::tower::util::service_fn(handler);
    /// let app = EchoService::builder(config)
    ///     .list_todos_service(svc)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: EchoService<::aws_smithy_http_server::routing::RoutingService<::aws_smithy_http_server::protocol::rest::router::RestRouter<::aws_smithy_http_server::routing::Route>, ::aws_smithy_http_server::protocol::rest_json_1::RestJson1>> = app;
    /// ```
    ///
                    pub fn list_todos_service<S, ServiceExtractors, UpgradeExtractors>(self, service: S) -> Self
                    where
                        S: ::aws_smithy_http_server::operation::OperationService<crate::operation_shape::ListTodos, ServiceExtractors>,

                        ModelPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::ListTodos,
                            ::aws_smithy_http_server::operation::Normalize<crate::operation_shape::ListTodos, S>
                        >,
                        ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::ListTodos,
                            ModelPl::Output
                        >,
                        HttpPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::ListTodos,
                            <
                                ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>
                                as ::aws_smithy_http_server::plugin::Plugin<
                                    EchoService<L>,
                                    crate::operation_shape::ListTodos,
                                    ModelPl::Output
                                >
                            >::Output
                        >,

                        HttpPl::Output: ::tower::Service<::http::Request<Body>, Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>, Error = ::std::convert::Infallible> + Clone + Send + 'static,
                        <HttpPl::Output as ::tower::Service<::http::Request<Body>>>::Future: Send + 'static,

                    {
        use ::aws_smithy_http_server::operation::OperationShapeExt;
        use ::aws_smithy_http_server::plugin::Plugin;
        let svc = crate::operation_shape::ListTodos::from_service(service);
        let svc = self.model_plugin.apply(svc);
        let svc = ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.list_todos_custom(svc)
    }

    /// Sets the [`ListTodos`](crate::operation_shape::ListTodos) to a custom [`Service`](tower::Service).
    /// not constrained by the Smithy contract.
    fn list_todos_custom<S>(mut self, svc: S) -> Self
    where
        S: ::tower::Service<
                ::http::Request<Body>,
                Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>,
                Error = ::std::convert::Infallible,
            > + Clone
            + Send
            + 'static,
        S::Future: Send + 'static,
    {
        self.list_todos = Some(::aws_smithy_http_server::routing::Route::new(svc));
        self
    }

    /// Sets the [`Signin`](crate::operation_shape::Signin) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](::aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](::aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use echo_server_sdk::{EchoService, EchoServiceConfig};
    ///
    /// use echo_server_sdk::{input, output, error};
    ///
    /// async fn handler(input: input::SigninInput) -> Result<output::SigninOutput, error::SigninError> {
    ///     todo!()
    /// }
    ///
    /// let config = EchoServiceConfig::builder().build();
    /// let app = EchoService::builder(config)
    ///     .signin(handler)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: EchoService<::aws_smithy_http_server::routing::RoutingService<::aws_smithy_http_server::protocol::rest::router::RestRouter<::aws_smithy_http_server::routing::Route>, ::aws_smithy_http_server::protocol::rest_json_1::RestJson1>> = app;
    /// ```
    ///
                    pub fn signin<HandlerType, HandlerExtractors, UpgradeExtractors>(self, handler: HandlerType) -> Self
                    where
                        HandlerType: ::aws_smithy_http_server::operation::Handler<crate::operation_shape::Signin, HandlerExtractors>,

                        ModelPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::Signin,
                            ::aws_smithy_http_server::operation::IntoService<crate::operation_shape::Signin, HandlerType>
                        >,
                        ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::Signin,
                            ModelPl::Output
                        >,
                        HttpPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::Signin,
                            <
                                ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>
                                as ::aws_smithy_http_server::plugin::Plugin<
                                    EchoService<L>,
                                    crate::operation_shape::Signin,
                                    ModelPl::Output
                                >
                            >::Output
                        >,

                        HttpPl::Output: ::tower::Service<::http::Request<Body>, Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>, Error = ::std::convert::Infallible> + Clone + Send + 'static,
                        <HttpPl::Output as ::tower::Service<::http::Request<Body>>>::Future: Send + 'static,

                    {
        use ::aws_smithy_http_server::operation::OperationShapeExt;
        use ::aws_smithy_http_server::plugin::Plugin;
        let svc = crate::operation_shape::Signin::from_handler(handler);
        let svc = self.model_plugin.apply(svc);
        let svc = ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.signin_custom(svc)
    }

    /// Sets the [`Signin`](crate::operation_shape::Signin) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](::aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](::aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use echo_server_sdk::{EchoService, EchoServiceConfig};
    ///
    /// use echo_server_sdk::{input, output, error};
    ///
    /// async fn handler(input: input::SigninInput) -> Result<output::SigninOutput, error::SigninError> {
    ///     todo!()
    /// }
    ///
    /// let config = EchoServiceConfig::builder().build();
    /// let svc = ::tower::util::service_fn(handler);
    /// let app = EchoService::builder(config)
    ///     .signin_service(svc)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: EchoService<::aws_smithy_http_server::routing::RoutingService<::aws_smithy_http_server::protocol::rest::router::RestRouter<::aws_smithy_http_server::routing::Route>, ::aws_smithy_http_server::protocol::rest_json_1::RestJson1>> = app;
    /// ```
    ///
                    pub fn signin_service<S, ServiceExtractors, UpgradeExtractors>(self, service: S) -> Self
                    where
                        S: ::aws_smithy_http_server::operation::OperationService<crate::operation_shape::Signin, ServiceExtractors>,

                        ModelPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::Signin,
                            ::aws_smithy_http_server::operation::Normalize<crate::operation_shape::Signin, S>
                        >,
                        ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::Signin,
                            ModelPl::Output
                        >,
                        HttpPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::Signin,
                            <
                                ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>
                                as ::aws_smithy_http_server::plugin::Plugin<
                                    EchoService<L>,
                                    crate::operation_shape::Signin,
                                    ModelPl::Output
                                >
                            >::Output
                        >,

                        HttpPl::Output: ::tower::Service<::http::Request<Body>, Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>, Error = ::std::convert::Infallible> + Clone + Send + 'static,
                        <HttpPl::Output as ::tower::Service<::http::Request<Body>>>::Future: Send + 'static,

                    {
        use ::aws_smithy_http_server::operation::OperationShapeExt;
        use ::aws_smithy_http_server::plugin::Plugin;
        let svc = crate::operation_shape::Signin::from_service(service);
        let svc = self.model_plugin.apply(svc);
        let svc = ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.signin_custom(svc)
    }

    /// Sets the [`Signin`](crate::operation_shape::Signin) to a custom [`Service`](tower::Service).
    /// not constrained by the Smithy contract.
    fn signin_custom<S>(mut self, svc: S) -> Self
    where
        S: ::tower::Service<
                ::http::Request<Body>,
                Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>,
                Error = ::std::convert::Infallible,
            > + Clone
            + Send
            + 'static,
        S::Future: Send + 'static,
    {
        self.signin = Some(::aws_smithy_http_server::routing::Route::new(svc));
        self
    }

    /// Sets the [`UpdateTodo`](crate::operation_shape::UpdateTodo) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](::aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](::aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use echo_server_sdk::{EchoService, EchoServiceConfig};
    ///
    /// use echo_server_sdk::{input, output, error};
    ///
    /// async fn handler(input: input::UpdateTodoInput) -> Result<output::UpdateTodoOutput, error::UpdateTodoError> {
    ///     todo!()
    /// }
    ///
    /// let config = EchoServiceConfig::builder().build();
    /// let app = EchoService::builder(config)
    ///     .update_todo(handler)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: EchoService<::aws_smithy_http_server::routing::RoutingService<::aws_smithy_http_server::protocol::rest::router::RestRouter<::aws_smithy_http_server::routing::Route>, ::aws_smithy_http_server::protocol::rest_json_1::RestJson1>> = app;
    /// ```
    ///
                    pub fn update_todo<HandlerType, HandlerExtractors, UpgradeExtractors>(self, handler: HandlerType) -> Self
                    where
                        HandlerType: ::aws_smithy_http_server::operation::Handler<crate::operation_shape::UpdateTodo, HandlerExtractors>,

                        ModelPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::UpdateTodo,
                            ::aws_smithy_http_server::operation::IntoService<crate::operation_shape::UpdateTodo, HandlerType>
                        >,
                        ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::UpdateTodo,
                            ModelPl::Output
                        >,
                        HttpPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::UpdateTodo,
                            <
                                ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>
                                as ::aws_smithy_http_server::plugin::Plugin<
                                    EchoService<L>,
                                    crate::operation_shape::UpdateTodo,
                                    ModelPl::Output
                                >
                            >::Output
                        >,

                        HttpPl::Output: ::tower::Service<::http::Request<Body>, Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>, Error = ::std::convert::Infallible> + Clone + Send + 'static,
                        <HttpPl::Output as ::tower::Service<::http::Request<Body>>>::Future: Send + 'static,

                    {
        use ::aws_smithy_http_server::operation::OperationShapeExt;
        use ::aws_smithy_http_server::plugin::Plugin;
        let svc = crate::operation_shape::UpdateTodo::from_handler(handler);
        let svc = self.model_plugin.apply(svc);
        let svc = ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.update_todo_custom(svc)
    }

    /// Sets the [`UpdateTodo`](crate::operation_shape::UpdateTodo) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](::aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](::aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use echo_server_sdk::{EchoService, EchoServiceConfig};
    ///
    /// use echo_server_sdk::{input, output, error};
    ///
    /// async fn handler(input: input::UpdateTodoInput) -> Result<output::UpdateTodoOutput, error::UpdateTodoError> {
    ///     todo!()
    /// }
    ///
    /// let config = EchoServiceConfig::builder().build();
    /// let svc = ::tower::util::service_fn(handler);
    /// let app = EchoService::builder(config)
    ///     .update_todo_service(svc)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: EchoService<::aws_smithy_http_server::routing::RoutingService<::aws_smithy_http_server::protocol::rest::router::RestRouter<::aws_smithy_http_server::routing::Route>, ::aws_smithy_http_server::protocol::rest_json_1::RestJson1>> = app;
    /// ```
    ///
                    pub fn update_todo_service<S, ServiceExtractors, UpgradeExtractors>(self, service: S) -> Self
                    where
                        S: ::aws_smithy_http_server::operation::OperationService<crate::operation_shape::UpdateTodo, ServiceExtractors>,

                        ModelPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::UpdateTodo,
                            ::aws_smithy_http_server::operation::Normalize<crate::operation_shape::UpdateTodo, S>
                        >,
                        ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::UpdateTodo,
                            ModelPl::Output
                        >,
                        HttpPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::UpdateTodo,
                            <
                                ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>
                                as ::aws_smithy_http_server::plugin::Plugin<
                                    EchoService<L>,
                                    crate::operation_shape::UpdateTodo,
                                    ModelPl::Output
                                >
                            >::Output
                        >,

                        HttpPl::Output: ::tower::Service<::http::Request<Body>, Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>, Error = ::std::convert::Infallible> + Clone + Send + 'static,
                        <HttpPl::Output as ::tower::Service<::http::Request<Body>>>::Future: Send + 'static,

                    {
        use ::aws_smithy_http_server::operation::OperationShapeExt;
        use ::aws_smithy_http_server::plugin::Plugin;
        let svc = crate::operation_shape::UpdateTodo::from_service(service);
        let svc = self.model_plugin.apply(svc);
        let svc = ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.update_todo_custom(svc)
    }

    /// Sets the [`UpdateTodo`](crate::operation_shape::UpdateTodo) to a custom [`Service`](tower::Service).
    /// not constrained by the Smithy contract.
    fn update_todo_custom<S>(mut self, svc: S) -> Self
    where
        S: ::tower::Service<
                ::http::Request<Body>,
                Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>,
                Error = ::std::convert::Infallible,
            > + Clone
            + Send
            + 'static,
        S::Future: Send + 'static,
    {
        self.update_todo = Some(::aws_smithy_http_server::routing::Route::new(svc));
        self
    }

    /// Sets the [`UpdateTodoStatus`](crate::operation_shape::UpdateTodoStatus) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](::aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](::aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use echo_server_sdk::{EchoService, EchoServiceConfig};
    ///
    /// use echo_server_sdk::{input, output, error};
    ///
    /// async fn handler(input: input::UpdateTodoStatusInput) -> Result<output::UpdateTodoStatusOutput, error::UpdateTodoStatusError> {
    ///     todo!()
    /// }
    ///
    /// let config = EchoServiceConfig::builder().build();
    /// let app = EchoService::builder(config)
    ///     .update_todo_status(handler)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: EchoService<::aws_smithy_http_server::routing::RoutingService<::aws_smithy_http_server::protocol::rest::router::RestRouter<::aws_smithy_http_server::routing::Route>, ::aws_smithy_http_server::protocol::rest_json_1::RestJson1>> = app;
    /// ```
    ///
                    pub fn update_todo_status<HandlerType, HandlerExtractors, UpgradeExtractors>(self, handler: HandlerType) -> Self
                    where
                        HandlerType: ::aws_smithy_http_server::operation::Handler<crate::operation_shape::UpdateTodoStatus, HandlerExtractors>,

                        ModelPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::UpdateTodoStatus,
                            ::aws_smithy_http_server::operation::IntoService<crate::operation_shape::UpdateTodoStatus, HandlerType>
                        >,
                        ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::UpdateTodoStatus,
                            ModelPl::Output
                        >,
                        HttpPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::UpdateTodoStatus,
                            <
                                ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>
                                as ::aws_smithy_http_server::plugin::Plugin<
                                    EchoService<L>,
                                    crate::operation_shape::UpdateTodoStatus,
                                    ModelPl::Output
                                >
                            >::Output
                        >,

                        HttpPl::Output: ::tower::Service<::http::Request<Body>, Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>, Error = ::std::convert::Infallible> + Clone + Send + 'static,
                        <HttpPl::Output as ::tower::Service<::http::Request<Body>>>::Future: Send + 'static,

                    {
        use ::aws_smithy_http_server::operation::OperationShapeExt;
        use ::aws_smithy_http_server::plugin::Plugin;
        let svc = crate::operation_shape::UpdateTodoStatus::from_handler(handler);
        let svc = self.model_plugin.apply(svc);
        let svc = ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.update_todo_status_custom(svc)
    }

    /// Sets the [`UpdateTodoStatus`](crate::operation_shape::UpdateTodoStatus) operation.
    ///
    /// This should be an async function satisfying the [`Handler`](::aws_smithy_http_server::operation::Handler) trait.
    /// See the [operation module documentation](::aws_smithy_http_server::operation) for more information.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use echo_server_sdk::{EchoService, EchoServiceConfig};
    ///
    /// use echo_server_sdk::{input, output, error};
    ///
    /// async fn handler(input: input::UpdateTodoStatusInput) -> Result<output::UpdateTodoStatusOutput, error::UpdateTodoStatusError> {
    ///     todo!()
    /// }
    ///
    /// let config = EchoServiceConfig::builder().build();
    /// let svc = ::tower::util::service_fn(handler);
    /// let app = EchoService::builder(config)
    ///     .update_todo_status_service(svc)
    ///     /* Set other handlers */
    ///     .build()
    ///     .unwrap();
    /// # let app: EchoService<::aws_smithy_http_server::routing::RoutingService<::aws_smithy_http_server::protocol::rest::router::RestRouter<::aws_smithy_http_server::routing::Route>, ::aws_smithy_http_server::protocol::rest_json_1::RestJson1>> = app;
    /// ```
    ///
                    pub fn update_todo_status_service<S, ServiceExtractors, UpgradeExtractors>(self, service: S) -> Self
                    where
                        S: ::aws_smithy_http_server::operation::OperationService<crate::operation_shape::UpdateTodoStatus, ServiceExtractors>,

                        ModelPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::UpdateTodoStatus,
                            ::aws_smithy_http_server::operation::Normalize<crate::operation_shape::UpdateTodoStatus, S>
                        >,
                        ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::UpdateTodoStatus,
                            ModelPl::Output
                        >,
                        HttpPl: ::aws_smithy_http_server::plugin::Plugin<
                            EchoService<L>,
                            crate::operation_shape::UpdateTodoStatus,
                            <
                                ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>
                                as ::aws_smithy_http_server::plugin::Plugin<
                                    EchoService<L>,
                                    crate::operation_shape::UpdateTodoStatus,
                                    ModelPl::Output
                                >
                            >::Output
                        >,

                        HttpPl::Output: ::tower::Service<::http::Request<Body>, Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>, Error = ::std::convert::Infallible> + Clone + Send + 'static,
                        <HttpPl::Output as ::tower::Service<::http::Request<Body>>>::Future: Send + 'static,

                    {
        use ::aws_smithy_http_server::operation::OperationShapeExt;
        use ::aws_smithy_http_server::plugin::Plugin;
        let svc = crate::operation_shape::UpdateTodoStatus::from_service(service);
        let svc = self.model_plugin.apply(svc);
        let svc = ::aws_smithy_http_server::operation::UpgradePlugin::<UpgradeExtractors>::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.update_todo_status_custom(svc)
    }

    /// Sets the [`UpdateTodoStatus`](crate::operation_shape::UpdateTodoStatus) to a custom [`Service`](tower::Service).
    /// not constrained by the Smithy contract.
    fn update_todo_status_custom<S>(mut self, svc: S) -> Self
    where
        S: ::tower::Service<
                ::http::Request<Body>,
                Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>,
                Error = ::std::convert::Infallible,
            > + Clone
            + Send
            + 'static,
        S::Future: Send + 'static,
    {
        self.update_todo_status = Some(::aws_smithy_http_server::routing::Route::new(svc));
        self
    }
}

impl<Body, L, HttpPl, ModelPl> EchoServiceBuilder<Body, L, HttpPl, ModelPl> {
    /// Constructs a [`EchoService`] from the arguments provided to the builder.
    ///
    /// Forgetting to register a handler for one or more operations will result in an error.
    ///
    /// Check out [`EchoServiceBuilder::build_unchecked`] if you'd prefer the service to return status code 500 when an
    /// unspecified route is requested.
    pub fn build(
        self,
    ) -> Result<
        EchoService<
            ::aws_smithy_http_server::routing::RoutingService<
                ::aws_smithy_http_server::protocol::rest::router::RestRouter<L::Service>,
                ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
            >,
        >,
        MissingOperationsError,
    >
    where
        L: ::tower::Layer<::aws_smithy_http_server::routing::Route<Body>>,
    {
        let router = {
            use ::aws_smithy_http_server::operation::OperationShape;
            let mut missing_operation_names = std::collections::HashMap::new();
            if self.create_todo.is_none() {
                missing_operation_names
                    .insert(crate::operation_shape::CreateTodo::ID, ".create_todo()");
            }
            if self.delete_todo.is_none() {
                missing_operation_names
                    .insert(crate::operation_shape::DeleteTodo::ID, ".delete_todo()");
            }
            if self.echo_message.is_none() {
                missing_operation_names
                    .insert(crate::operation_shape::EchoMessage::ID, ".echo_message()");
            }
            if self.get_todo.is_none() {
                missing_operation_names.insert(crate::operation_shape::GetTodo::ID, ".get_todo()");
            }
            if self.list_todos.is_none() {
                missing_operation_names
                    .insert(crate::operation_shape::ListTodos::ID, ".list_todos()");
            }
            if self.signin.is_none() {
                missing_operation_names.insert(crate::operation_shape::Signin::ID, ".signin()");
            }
            if self.update_todo.is_none() {
                missing_operation_names
                    .insert(crate::operation_shape::UpdateTodo::ID, ".update_todo()");
            }
            if self.update_todo_status.is_none() {
                missing_operation_names.insert(
                    crate::operation_shape::UpdateTodoStatus::ID,
                    ".update_todo_status()",
                );
            }
            if !missing_operation_names.is_empty() {
                return Err(MissingOperationsError {
                    operation_names2setter_methods: missing_operation_names,
                });
            }
            let unexpected_error_msg = "this should never panic since we are supposed to check beforehand that a handler has been registered for this operation; please file a bug report under https://github.com/smithy-lang/smithy-rs/issues";

            ::aws_smithy_http_server::protocol::rest::router::RestRouter::from_iter([
                (
                    request_specs::create_todo(),
                    self.create_todo.expect(unexpected_error_msg),
                ),
                (
                    request_specs::delete_todo(),
                    self.delete_todo.expect(unexpected_error_msg),
                ),
                (
                    request_specs::echo_message(),
                    self.echo_message.expect(unexpected_error_msg),
                ),
                (
                    request_specs::get_todo(),
                    self.get_todo.expect(unexpected_error_msg),
                ),
                (
                    request_specs::list_todos(),
                    self.list_todos.expect(unexpected_error_msg),
                ),
                (
                    request_specs::signin(),
                    self.signin.expect(unexpected_error_msg),
                ),
                (
                    request_specs::update_todo(),
                    self.update_todo.expect(unexpected_error_msg),
                ),
                (
                    request_specs::update_todo_status(),
                    self.update_todo_status.expect(unexpected_error_msg),
                ),
            ])
        };
        let svc = ::aws_smithy_http_server::routing::RoutingService::new(router);
        let svc = svc.map(|s| s.layer(self.layer));
        Ok(EchoService { svc })
    }

    /// Constructs a [`EchoService`] from the arguments provided to the builder.
    /// Operations without a handler default to returning 500 Internal Server Error to the caller.
    ///
    /// Check out [`EchoServiceBuilder::build`] if you'd prefer the builder to fail if one or more operations do
    /// not have a registered handler.
    pub fn build_unchecked(self) -> EchoService<L::Service>
    where
        Body: Send + 'static,
        L: ::tower::Layer<
            ::aws_smithy_http_server::routing::RoutingService<
                ::aws_smithy_http_server::protocol::rest::router::RestRouter<
                    ::aws_smithy_http_server::routing::Route<Body>,
                >,
                ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
            >,
        >,
    {
        let router = ::aws_smithy_http_server::protocol::rest::router::RestRouter::from_iter([
            (
                request_specs::create_todo(),
                self.create_todo.unwrap_or_else(|| {
                    let svc = ::aws_smithy_http_server::operation::MissingFailure::<
                        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
                    >::default();
                    ::aws_smithy_http_server::routing::Route::new(svc)
                }),
            ),
            (
                request_specs::delete_todo(),
                self.delete_todo.unwrap_or_else(|| {
                    let svc = ::aws_smithy_http_server::operation::MissingFailure::<
                        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
                    >::default();
                    ::aws_smithy_http_server::routing::Route::new(svc)
                }),
            ),
            (
                request_specs::echo_message(),
                self.echo_message.unwrap_or_else(|| {
                    let svc = ::aws_smithy_http_server::operation::MissingFailure::<
                        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
                    >::default();
                    ::aws_smithy_http_server::routing::Route::new(svc)
                }),
            ),
            (
                request_specs::get_todo(),
                self.get_todo.unwrap_or_else(|| {
                    let svc = ::aws_smithy_http_server::operation::MissingFailure::<
                        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
                    >::default();
                    ::aws_smithy_http_server::routing::Route::new(svc)
                }),
            ),
            (
                request_specs::list_todos(),
                self.list_todos.unwrap_or_else(|| {
                    let svc = ::aws_smithy_http_server::operation::MissingFailure::<
                        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
                    >::default();
                    ::aws_smithy_http_server::routing::Route::new(svc)
                }),
            ),
            (
                request_specs::signin(),
                self.signin.unwrap_or_else(|| {
                    let svc = ::aws_smithy_http_server::operation::MissingFailure::<
                        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
                    >::default();
                    ::aws_smithy_http_server::routing::Route::new(svc)
                }),
            ),
            (
                request_specs::update_todo(),
                self.update_todo.unwrap_or_else(|| {
                    let svc = ::aws_smithy_http_server::operation::MissingFailure::<
                        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
                    >::default();
                    ::aws_smithy_http_server::routing::Route::new(svc)
                }),
            ),
            (
                request_specs::update_todo_status(),
                self.update_todo_status.unwrap_or_else(|| {
                    let svc = ::aws_smithy_http_server::operation::MissingFailure::<
                        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
                    >::default();
                    ::aws_smithy_http_server::routing::Route::new(svc)
                }),
            ),
        ]);
        let svc = self
            .layer
            .layer(::aws_smithy_http_server::routing::RoutingService::new(
                router,
            ));
        EchoService { svc }
    }
}

/// The error encountered when calling the [`EchoServiceBuilder::build`] method if one or more operation handlers are not
/// specified.
#[derive(Debug)]
pub struct MissingOperationsError {
    operation_names2setter_methods:
        std::collections::HashMap<::aws_smithy_http_server::shape_id::ShapeId, &'static str>,
}

impl std::fmt::Display for MissingOperationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "You must specify a handler for all operations attached to `EchoService`.\n\
                            We are missing handlers for the following operations:\n",
        )?;
        for operation_name in self.operation_names2setter_methods.keys() {
            writeln!(f, "- {}", operation_name.absolute())?;
        }

        writeln!(
            f,
            "\nUse the dedicated methods on `EchoServiceBuilder` to register the missing handlers:"
        )?;
        for setter_name in self.operation_names2setter_methods.values() {
            writeln!(f, "- {}", setter_name)?;
        }
        Ok(())
    }
}

impl std::error::Error for MissingOperationsError {}

mod request_specs {
    pub(super) fn create_todo() -> ::aws_smithy_http_server::routing::request_spec::RequestSpec {
        ::aws_smithy_http_server::routing::request_spec::RequestSpec::new(
                    ::http::Method::POST,
                    ::aws_smithy_http_server::routing::request_spec::UriSpec::new(
                        ::aws_smithy_http_server::routing::request_spec::PathAndQuerySpec::new(
                            ::aws_smithy_http_server::routing::request_spec::PathSpec::from_vector_unchecked(vec![
    ::aws_smithy_http_server::routing::request_spec::PathSegment::Literal(String::from("todos")),
]),
                            ::aws_smithy_http_server::routing::request_spec::QuerySpec::from_vector_unchecked(vec![
])
                        )
                    ),
                )
    }
    pub(super) fn delete_todo() -> ::aws_smithy_http_server::routing::request_spec::RequestSpec {
        ::aws_smithy_http_server::routing::request_spec::RequestSpec::new(
                    ::http::Method::DELETE,
                    ::aws_smithy_http_server::routing::request_spec::UriSpec::new(
                        ::aws_smithy_http_server::routing::request_spec::PathAndQuerySpec::new(
                            ::aws_smithy_http_server::routing::request_spec::PathSpec::from_vector_unchecked(vec![
    ::aws_smithy_http_server::routing::request_spec::PathSegment::Literal(String::from("todos")),
    ::aws_smithy_http_server::routing::request_spec::PathSegment::Label,
]),
                            ::aws_smithy_http_server::routing::request_spec::QuerySpec::from_vector_unchecked(vec![
])
                        )
                    ),
                )
    }
    pub(super) fn echo_message() -> ::aws_smithy_http_server::routing::request_spec::RequestSpec {
        ::aws_smithy_http_server::routing::request_spec::RequestSpec::new(
                    ::http::Method::POST,
                    ::aws_smithy_http_server::routing::request_spec::UriSpec::new(
                        ::aws_smithy_http_server::routing::request_spec::PathAndQuerySpec::new(
                            ::aws_smithy_http_server::routing::request_spec::PathSpec::from_vector_unchecked(vec![
    ::aws_smithy_http_server::routing::request_spec::PathSegment::Literal(String::from("echo")),
]),
                            ::aws_smithy_http_server::routing::request_spec::QuerySpec::from_vector_unchecked(vec![
])
                        )
                    ),
                )
    }
    pub(super) fn get_todo() -> ::aws_smithy_http_server::routing::request_spec::RequestSpec {
        ::aws_smithy_http_server::routing::request_spec::RequestSpec::new(
                    ::http::Method::GET,
                    ::aws_smithy_http_server::routing::request_spec::UriSpec::new(
                        ::aws_smithy_http_server::routing::request_spec::PathAndQuerySpec::new(
                            ::aws_smithy_http_server::routing::request_spec::PathSpec::from_vector_unchecked(vec![
    ::aws_smithy_http_server::routing::request_spec::PathSegment::Literal(String::from("todos")),
    ::aws_smithy_http_server::routing::request_spec::PathSegment::Label,
]),
                            ::aws_smithy_http_server::routing::request_spec::QuerySpec::from_vector_unchecked(vec![
])
                        )
                    ),
                )
    }
    pub(super) fn list_todos() -> ::aws_smithy_http_server::routing::request_spec::RequestSpec {
        ::aws_smithy_http_server::routing::request_spec::RequestSpec::new(
                    ::http::Method::GET,
                    ::aws_smithy_http_server::routing::request_spec::UriSpec::new(
                        ::aws_smithy_http_server::routing::request_spec::PathAndQuerySpec::new(
                            ::aws_smithy_http_server::routing::request_spec::PathSpec::from_vector_unchecked(vec![
    ::aws_smithy_http_server::routing::request_spec::PathSegment::Literal(String::from("todos")),
]),
                            ::aws_smithy_http_server::routing::request_spec::QuerySpec::from_vector_unchecked(vec![
])
                        )
                    ),
                )
    }
    pub(super) fn signin() -> ::aws_smithy_http_server::routing::request_spec::RequestSpec {
        ::aws_smithy_http_server::routing::request_spec::RequestSpec::new(
                    ::http::Method::POST,
                    ::aws_smithy_http_server::routing::request_spec::UriSpec::new(
                        ::aws_smithy_http_server::routing::request_spec::PathAndQuerySpec::new(
                            ::aws_smithy_http_server::routing::request_spec::PathSpec::from_vector_unchecked(vec![
    ::aws_smithy_http_server::routing::request_spec::PathSegment::Literal(String::from("signin")),
]),
                            ::aws_smithy_http_server::routing::request_spec::QuerySpec::from_vector_unchecked(vec![
])
                        )
                    ),
                )
    }
    pub(super) fn update_todo() -> ::aws_smithy_http_server::routing::request_spec::RequestSpec {
        ::aws_smithy_http_server::routing::request_spec::RequestSpec::new(
                    ::http::Method::PUT,
                    ::aws_smithy_http_server::routing::request_spec::UriSpec::new(
                        ::aws_smithy_http_server::routing::request_spec::PathAndQuerySpec::new(
                            ::aws_smithy_http_server::routing::request_spec::PathSpec::from_vector_unchecked(vec![
    ::aws_smithy_http_server::routing::request_spec::PathSegment::Literal(String::from("todos")),
    ::aws_smithy_http_server::routing::request_spec::PathSegment::Label,
]),
                            ::aws_smithy_http_server::routing::request_spec::QuerySpec::from_vector_unchecked(vec![
])
                        )
                    ),
                )
    }
    pub(super) fn update_todo_status(
    ) -> ::aws_smithy_http_server::routing::request_spec::RequestSpec {
        ::aws_smithy_http_server::routing::request_spec::RequestSpec::new(
                    ::http::Method::PUT,
                    ::aws_smithy_http_server::routing::request_spec::UriSpec::new(
                        ::aws_smithy_http_server::routing::request_spec::PathAndQuerySpec::new(
                            ::aws_smithy_http_server::routing::request_spec::PathSpec::from_vector_unchecked(vec![
    ::aws_smithy_http_server::routing::request_spec::PathSegment::Literal(String::from("todos")),
    ::aws_smithy_http_server::routing::request_spec::PathSegment::Label,
    ::aws_smithy_http_server::routing::request_spec::PathSegment::Literal(String::from("status")),
]),
                            ::aws_smithy_http_server::routing::request_spec::QuerySpec::from_vector_unchecked(vec![
])
                        )
                    ),
                )
    }
}

/// Echoes input
///
/// See the [root](crate) documentation for more information.
#[derive(Clone)]
pub struct EchoService<
    S = ::aws_smithy_http_server::routing::RoutingService<
        ::aws_smithy_http_server::protocol::rest::router::RestRouter<
            ::aws_smithy_http_server::routing::Route<::aws_smithy_http_server::body::BoxBody>,
        >,
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    >,
> {
    // This is the router wrapped by layers.
    svc: S,
}

impl EchoService<()> {
    /// Constructs a builder for [`EchoService`].
    /// You must specify a configuration object holding any plugins and layers that should be applied
    /// to the operations in this service.
    pub fn builder<
        Body,
        L,
        HttpPl: ::aws_smithy_http_server::plugin::HttpMarker,
        ModelPl: ::aws_smithy_http_server::plugin::ModelMarker,
    >(
        config: EchoServiceConfig<L, HttpPl, ModelPl>,
    ) -> EchoServiceBuilder<Body, L, HttpPl, ModelPl> {
        EchoServiceBuilder {
            create_todo: None,
            delete_todo: None,
            echo_message: None,
            get_todo: None,
            list_todos: None,
            signin: None,
            update_todo: None,
            update_todo_status: None,
            layer: config.layers,
            http_plugin: config.http_plugins,
            model_plugin: config.model_plugins,
        }
    }

    /// Constructs a builder for [`EchoService`].
    /// You must specify what plugins should be applied to the operations in this service.
    ///
    /// Use [`EchoService::builder_without_plugins`] if you don't need to apply plugins.
    ///
    /// Check out [`HttpPlugins`](::aws_smithy_http_server::plugin::HttpPlugins) and
    /// [`ModelPlugins`](::aws_smithy_http_server::plugin::ModelPlugins) if you need to apply
    /// multiple plugins.
    #[deprecated(
        since = "0.57.0",
        note = "please use the `builder` constructor and register plugins on the `EchoServiceConfig` object instead; see https://github.com/smithy-lang/smithy-rs/discussions/3096"
    )]
    pub fn builder_with_plugins<
        Body,
        HttpPl: ::aws_smithy_http_server::plugin::HttpMarker,
        ModelPl: ::aws_smithy_http_server::plugin::ModelMarker,
    >(
        http_plugin: HttpPl,
        model_plugin: ModelPl,
    ) -> EchoServiceBuilder<Body, ::tower::layer::util::Identity, HttpPl, ModelPl> {
        EchoServiceBuilder {
            create_todo: None,
            delete_todo: None,
            echo_message: None,
            get_todo: None,
            list_todos: None,
            signin: None,
            update_todo: None,
            update_todo_status: None,
            layer: ::tower::layer::util::Identity::new(),
            http_plugin,
            model_plugin,
        }
    }

    /// Constructs a builder for [`EchoService`].
    ///
    /// Use [`EchoService::builder_with_plugins`] if you need to specify plugins.
    #[deprecated(
        since = "0.57.0",
        note = "please use the `builder` constructor instead; see https://github.com/smithy-lang/smithy-rs/discussions/3096"
    )]
    pub fn builder_without_plugins<Body>() -> EchoServiceBuilder<
        Body,
        ::tower::layer::util::Identity,
        ::aws_smithy_http_server::plugin::IdentityPlugin,
        ::aws_smithy_http_server::plugin::IdentityPlugin,
    > {
        Self::builder_with_plugins(
            ::aws_smithy_http_server::plugin::IdentityPlugin,
            ::aws_smithy_http_server::plugin::IdentityPlugin,
        )
    }
}

impl<S> EchoService<S> {
    /// Converts [`EchoService`] into a [`MakeService`](tower::make::MakeService).
    pub fn into_make_service(self) -> ::aws_smithy_http_server::routing::IntoMakeService<Self> {
        ::aws_smithy_http_server::routing::IntoMakeService::new(self)
    }

    /// Converts [`EchoService`] into a [`MakeService`](tower::make::MakeService) with [`ConnectInfo`](::aws_smithy_http_server::request::connect_info::ConnectInfo).
    pub fn into_make_service_with_connect_info<C>(
        self,
    ) -> ::aws_smithy_http_server::routing::IntoMakeServiceWithConnectInfo<Self, C> {
        ::aws_smithy_http_server::routing::IntoMakeServiceWithConnectInfo::new(self)
    }
}

impl<S>
    EchoService<
        ::aws_smithy_http_server::routing::RoutingService<
            ::aws_smithy_http_server::protocol::rest::router::RestRouter<S>,
            ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
        >,
    >
{
    /// Applies a [`Layer`](::tower::Layer) uniformly to all routes.
    #[deprecated(
        since = "0.57.0",
        note = "please add layers to the `EchoServiceConfig` object instead; see https://github.com/smithy-lang/smithy-rs/discussions/3096"
    )]
    pub fn layer<L>(
        self,
        layer: &L,
    ) -> EchoService<
        ::aws_smithy_http_server::routing::RoutingService<
            ::aws_smithy_http_server::protocol::rest::router::RestRouter<L::Service>,
            ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
        >,
    >
    where
        L: ::tower::Layer<S>,
    {
        EchoService {
            svc: self.svc.map(|s| s.layer(layer)),
        }
    }

    /// Applies [`Route::new`](::aws_smithy_http_server::routing::Route::new) to all routes.
    ///
    /// This has the effect of erasing all types accumulated via layers.
    pub fn boxed<B>(
        self,
    ) -> EchoService<
        ::aws_smithy_http_server::routing::RoutingService<
            ::aws_smithy_http_server::protocol::rest::router::RestRouter<
                ::aws_smithy_http_server::routing::Route<B>,
            >,
            ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
        >,
    >
    where
        S: ::tower::Service<
            ::http::Request<B>,
            Response = ::http::Response<::aws_smithy_http_server::body::BoxBody>,
            Error = std::convert::Infallible,
        >,
        S: Clone + Send + 'static,
        S::Future: Send + 'static,
    {
        self.layer(&::tower::layer::layer_fn(
            ::aws_smithy_http_server::routing::Route::new,
        ))
    }
}

impl<S, R> ::tower::Service<R> for EchoService<S>
where
    S: ::tower::Service<R>,
{
    type Response = S::Response;
    type Error = S::Error;
    type Future = S::Future;

    fn poll_ready(
        &mut self,
        cx: &mut std::task::Context,
    ) -> std::task::Poll<Result<(), Self::Error>> {
        self.svc.poll_ready(cx)
    }

    fn call(&mut self, request: R) -> Self::Future {
        self.svc.call(request)
    }
}

/// An enumeration of all [operations](https://smithy.io/2.0/spec/service-types.html#operation) in EchoService.
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum Operation {
    CreateTodo,
    DeleteTodo,
    EchoMessage,
    GetTodo,
    ListTodos,
    Signin,
    UpdateTodo,
    UpdateTodoStatus,
}

impl Operation {
    /// Returns the [operations](https://smithy.io/2.0/spec/service-types.html#operation) [`ShapeId`](::aws_smithy_http_server::shape_id::ShapeId).
    pub fn shape_id(&self) -> ::aws_smithy_http_server::shape_id::ShapeId {
        match self {
            Operation::CreateTodo => ::aws_smithy_http_server::shape_id::ShapeId::new(
                "com.example#CreateTodo",
                "com.example",
                "CreateTodo",
            ),
            Operation::DeleteTodo => ::aws_smithy_http_server::shape_id::ShapeId::new(
                "com.example#DeleteTodo",
                "com.example",
                "DeleteTodo",
            ),
            Operation::EchoMessage => ::aws_smithy_http_server::shape_id::ShapeId::new(
                "com.example#EchoMessage",
                "com.example",
                "EchoMessage",
            ),
            Operation::GetTodo => ::aws_smithy_http_server::shape_id::ShapeId::new(
                "com.example#GetTodo",
                "com.example",
                "GetTodo",
            ),
            Operation::ListTodos => ::aws_smithy_http_server::shape_id::ShapeId::new(
                "com.example#ListTodos",
                "com.example",
                "ListTodos",
            ),
            Operation::Signin => ::aws_smithy_http_server::shape_id::ShapeId::new(
                "com.example#Signin",
                "com.example",
                "Signin",
            ),
            Operation::UpdateTodo => ::aws_smithy_http_server::shape_id::ShapeId::new(
                "com.example#UpdateTodo",
                "com.example",
                "UpdateTodo",
            ),
            Operation::UpdateTodoStatus => ::aws_smithy_http_server::shape_id::ShapeId::new(
                "com.example#UpdateTodoStatus",
                "com.example",
                "UpdateTodoStatus",
            ),
        }
    }
}
impl<L> ::aws_smithy_http_server::service::ContainsOperation<crate::operation_shape::CreateTodo>
    for EchoService<L>
{
    const VALUE: Operation = Operation::CreateTodo;
}
impl<L> ::aws_smithy_http_server::service::ContainsOperation<crate::operation_shape::DeleteTodo>
    for EchoService<L>
{
    const VALUE: Operation = Operation::DeleteTodo;
}
impl<L> ::aws_smithy_http_server::service::ContainsOperation<crate::operation_shape::EchoMessage>
    for EchoService<L>
{
    const VALUE: Operation = Operation::EchoMessage;
}
impl<L> ::aws_smithy_http_server::service::ContainsOperation<crate::operation_shape::GetTodo>
    for EchoService<L>
{
    const VALUE: Operation = Operation::GetTodo;
}
impl<L> ::aws_smithy_http_server::service::ContainsOperation<crate::operation_shape::ListTodos>
    for EchoService<L>
{
    const VALUE: Operation = Operation::ListTodos;
}
impl<L> ::aws_smithy_http_server::service::ContainsOperation<crate::operation_shape::Signin>
    for EchoService<L>
{
    const VALUE: Operation = Operation::Signin;
}
impl<L> ::aws_smithy_http_server::service::ContainsOperation<crate::operation_shape::UpdateTodo>
    for EchoService<L>
{
    const VALUE: Operation = Operation::UpdateTodo;
}
impl<L>
    ::aws_smithy_http_server::service::ContainsOperation<crate::operation_shape::UpdateTodoStatus>
    for EchoService<L>
{
    const VALUE: Operation = Operation::UpdateTodoStatus;
}

impl<S> ::aws_smithy_http_server::service::ServiceShape for EchoService<S> {
    const ID: ::aws_smithy_http_server::shape_id::ShapeId =
        ::aws_smithy_http_server::shape_id::ShapeId::new(
            "com.example#EchoService",
            "com.example",
            "EchoService",
        );

    const VERSION: Option<&'static str> = Some("2023-12-03");

    type Protocol = ::aws_smithy_http_server::protocol::rest_json_1::RestJson1;

    type Operations = Operation;
}
/// Configuration for the [`EchoService`]. This is the central place where to register and
/// configure [`::tower::Layer`]s, HTTP plugins, and model plugins.
///
/// ```rust,no_run
/// # use echo_server_sdk::EchoServiceConfig;
/// # use ::aws_smithy_http_server::plugin::IdentityPlugin;
/// # use ::tower::layer::util::Identity;
/// # let authentication_plugin = IdentityPlugin;
/// # let authorization_plugin = IdentityPlugin;
/// # let server_request_id_provider_layer = Identity::new();
/// let config = EchoServiceConfig::builder()
///     // Layers get executed first...
///     .layer(server_request_id_provider_layer)
///     // ...then HTTP plugins...
///     .http_plugin(authentication_plugin)
///     // ...and right after deserialization, model plugins.
///     .model_plugin(authorization_plugin)
///     .build();
/// ```
///
/// See the [`plugin`] system for details.
///
/// [`plugin`]: ::aws_smithy_http_server::plugin
#[derive(::std::fmt::Debug)]
pub struct EchoServiceConfig<L, H, M> {
    layers: L,
    http_plugins: H,
    model_plugins: M,
}

impl EchoServiceConfig<(), (), ()> {
    /// Returns a builder to construct the configuration.
    pub fn builder() -> EchoServiceConfigBuilder<
        ::tower::layer::util::Identity,
        ::aws_smithy_http_server::plugin::IdentityPlugin,
        ::aws_smithy_http_server::plugin::IdentityPlugin,
    > {
        EchoServiceConfigBuilder {
            layers: ::tower::layer::util::Identity::new(),
            http_plugins: ::aws_smithy_http_server::plugin::IdentityPlugin,
            model_plugins: ::aws_smithy_http_server::plugin::IdentityPlugin,
        }
    }
}

/// Builder returned by [`EchoServiceConfig::builder()`].
#[derive(::std::fmt::Debug)]
pub struct EchoServiceConfigBuilder<L, H, M> {
    pub(crate) layers: L,
    pub(crate) http_plugins: H,
    pub(crate) model_plugins: M,
}

impl<L, H, M> EchoServiceConfigBuilder<L, H, M> {
    /// Add a [`::tower::Layer`] to the service.
    pub fn layer<NewLayer>(
        self,
        layer: NewLayer,
    ) -> EchoServiceConfigBuilder<::tower::layer::util::Stack<NewLayer, L>, H, M> {
        EchoServiceConfigBuilder {
            layers: ::tower::layer::util::Stack::new(layer, self.layers),
            http_plugins: self.http_plugins,
            model_plugins: self.model_plugins,
        }
    }

    /// Add a HTTP [plugin] to the service.
    ///
    /// [plugin]: ::aws_smithy_http_server::plugin
    // We eagerly require `NewPlugin: HttpMarker`, despite not really needing it, because compiler
    // errors get _substantially_ better if the user makes a mistake.
    pub fn http_plugin<NewPlugin: ::aws_smithy_http_server::plugin::HttpMarker>(
        self,
        http_plugin: NewPlugin,
    ) -> EchoServiceConfigBuilder<L, ::aws_smithy_http_server::plugin::PluginStack<NewPlugin, H>, M>
    {
        EchoServiceConfigBuilder {
            layers: self.layers,
            http_plugins: ::aws_smithy_http_server::plugin::PluginStack::new(
                http_plugin,
                self.http_plugins,
            ),
            model_plugins: self.model_plugins,
        }
    }

    /// Add a model [plugin] to the service.
    ///
    /// [plugin]: ::aws_smithy_http_server::plugin
    // We eagerly require `NewPlugin: ModelMarker`, despite not really needing it, because compiler
    // errors get _substantially_ better if the user makes a mistake.
    pub fn model_plugin<NewPlugin: ::aws_smithy_http_server::plugin::ModelMarker>(
        self,
        model_plugin: NewPlugin,
    ) -> EchoServiceConfigBuilder<L, H, ::aws_smithy_http_server::plugin::PluginStack<NewPlugin, M>>
    {
        EchoServiceConfigBuilder {
            layers: self.layers,
            http_plugins: self.http_plugins,
            model_plugins: ::aws_smithy_http_server::plugin::PluginStack::new(
                model_plugin,
                self.model_plugins,
            ),
        }
    }

    /// Build the configuration.
    pub fn build(self) -> super::EchoServiceConfig<L, H, M> {
        super::EchoServiceConfig {
            layers: self.layers,
            http_plugins: self.http_plugins,
            model_plugins: self.model_plugins,
        }
    }
}
/// A macro to help with scoping [plugins](::aws_smithy_http_server::plugin) to a subset of all operations.
///
/// In contrast to [`aws_smithy_http_server::scope`](::aws_smithy_http_server::scope), this macro has knowledge
/// of the service and any operations _not_ specified will be placed in the opposing group.
///
/// # Example
///
/// ```rust
/// scope! {
///     /// Includes [`CreateTodo`], excluding all other operations.
///     struct ScopeA {
///         includes: [CreateTodo]
///     }
/// }
///
/// scope! {
///     /// Excludes [`CreateTodo`], excluding all other operations.
///     struct ScopeB {
///         excludes: [CreateTodo]
///     }
/// }
///
/// # use ::aws_smithy_http_server::plugin::{Plugin, Scoped};
/// # use echo_server_sdk::scope;
/// # struct MockPlugin;
/// # impl<S, Op, T> Plugin<S, Op, T> for MockPlugin { type Output = u32; fn apply(&self, input: T) -> u32 { 3 } }
/// # let scoped_a = Scoped::new::<ScopeA>(MockPlugin);
/// # let scoped_b = Scoped::new::<ScopeB>(MockPlugin);
/// # let a = Plugin::<(), echo_server_sdk::operation_shape::CreateTodo, u64>::apply(&scoped_a, 6);
/// # let b = Plugin::<(), echo_server_sdk::operation_shape::CreateTodo, u64>::apply(&scoped_b, 6);
/// # assert_eq!(a, 3_u32);
/// # assert_eq!(b, 6_u64);
/// ```
#[macro_export]
macro_rules! scope {
                    // Completed, render impls
                    (@ $ name: ident, $ contains: ident () ($($ temp: ident)*) ($($ not_member: ident)*)) => {
                        $(
                            impl ::aws_smithy_http_server::plugin::scoped::Membership<$ temp> for $ name {
                                type Contains = ::aws_smithy_http_server::plugin::scoped::$ contains;
                            }
                        )*
                        $(
                            impl ::aws_smithy_http_server::plugin::scoped::Membership<$ not_member> for $ name {
                                type Contains = ::aws_smithy_http_server::plugin::scoped::$ contains;
                            }
                        )*
                    };
                    // All `not_member`s exhausted, move `temp` into `not_member`
                    (@ $ name: ident, $ contains: ident ($($ member: ident)*) ($($ temp: ident)*) ()) => {
                        scope! { @ $ name, $ contains ($($ member)*) () ($($ temp)*) }
                    };

                        // CreateTodo match found, pop from both `member` and `not_member`
                        (@ $ name: ident, $ contains: ident (CreateTodo $($ member: ident)*) ($($ temp: ident)*) (CreateTodo $($ not_member: ident)*)) => {
                            scope! { @ $ name, $ contains ($($ member)*) ($($ temp)*) ($($ not_member)*) }
                        };
                        // CreateTodo match not found, pop from `not_member` into `temp` stack
                        (@ $ name: ident, $ contains: ident (CreateTodo $($ member: ident)*) ($($ temp: ident)*) ($ other: ident $($ not_member: ident)*)) => {
                            scope! { @ $ name, $ contains (CreateTodo $($ member)*) ($ other $($ temp)*) ($($ not_member)*) }
                        };

                        // DeleteTodo match found, pop from both `member` and `not_member`
                        (@ $ name: ident, $ contains: ident (DeleteTodo $($ member: ident)*) ($($ temp: ident)*) (DeleteTodo $($ not_member: ident)*)) => {
                            scope! { @ $ name, $ contains ($($ member)*) ($($ temp)*) ($($ not_member)*) }
                        };
                        // DeleteTodo match not found, pop from `not_member` into `temp` stack
                        (@ $ name: ident, $ contains: ident (DeleteTodo $($ member: ident)*) ($($ temp: ident)*) ($ other: ident $($ not_member: ident)*)) => {
                            scope! { @ $ name, $ contains (DeleteTodo $($ member)*) ($ other $($ temp)*) ($($ not_member)*) }
                        };

                        // EchoMessage match found, pop from both `member` and `not_member`
                        (@ $ name: ident, $ contains: ident (EchoMessage $($ member: ident)*) ($($ temp: ident)*) (EchoMessage $($ not_member: ident)*)) => {
                            scope! { @ $ name, $ contains ($($ member)*) ($($ temp)*) ($($ not_member)*) }
                        };
                        // EchoMessage match not found, pop from `not_member` into `temp` stack
                        (@ $ name: ident, $ contains: ident (EchoMessage $($ member: ident)*) ($($ temp: ident)*) ($ other: ident $($ not_member: ident)*)) => {
                            scope! { @ $ name, $ contains (EchoMessage $($ member)*) ($ other $($ temp)*) ($($ not_member)*) }
                        };

                        // GetTodo match found, pop from both `member` and `not_member`
                        (@ $ name: ident, $ contains: ident (GetTodo $($ member: ident)*) ($($ temp: ident)*) (GetTodo $($ not_member: ident)*)) => {
                            scope! { @ $ name, $ contains ($($ member)*) ($($ temp)*) ($($ not_member)*) }
                        };
                        // GetTodo match not found, pop from `not_member` into `temp` stack
                        (@ $ name: ident, $ contains: ident (GetTodo $($ member: ident)*) ($($ temp: ident)*) ($ other: ident $($ not_member: ident)*)) => {
                            scope! { @ $ name, $ contains (GetTodo $($ member)*) ($ other $($ temp)*) ($($ not_member)*) }
                        };

                        // ListTodos match found, pop from both `member` and `not_member`
                        (@ $ name: ident, $ contains: ident (ListTodos $($ member: ident)*) ($($ temp: ident)*) (ListTodos $($ not_member: ident)*)) => {
                            scope! { @ $ name, $ contains ($($ member)*) ($($ temp)*) ($($ not_member)*) }
                        };
                        // ListTodos match not found, pop from `not_member` into `temp` stack
                        (@ $ name: ident, $ contains: ident (ListTodos $($ member: ident)*) ($($ temp: ident)*) ($ other: ident $($ not_member: ident)*)) => {
                            scope! { @ $ name, $ contains (ListTodos $($ member)*) ($ other $($ temp)*) ($($ not_member)*) }
                        };

                        // Signin match found, pop from both `member` and `not_member`
                        (@ $ name: ident, $ contains: ident (Signin $($ member: ident)*) ($($ temp: ident)*) (Signin $($ not_member: ident)*)) => {
                            scope! { @ $ name, $ contains ($($ member)*) ($($ temp)*) ($($ not_member)*) }
                        };
                        // Signin match not found, pop from `not_member` into `temp` stack
                        (@ $ name: ident, $ contains: ident (Signin $($ member: ident)*) ($($ temp: ident)*) ($ other: ident $($ not_member: ident)*)) => {
                            scope! { @ $ name, $ contains (Signin $($ member)*) ($ other $($ temp)*) ($($ not_member)*) }
                        };

                        // UpdateTodo match found, pop from both `member` and `not_member`
                        (@ $ name: ident, $ contains: ident (UpdateTodo $($ member: ident)*) ($($ temp: ident)*) (UpdateTodo $($ not_member: ident)*)) => {
                            scope! { @ $ name, $ contains ($($ member)*) ($($ temp)*) ($($ not_member)*) }
                        };
                        // UpdateTodo match not found, pop from `not_member` into `temp` stack
                        (@ $ name: ident, $ contains: ident (UpdateTodo $($ member: ident)*) ($($ temp: ident)*) ($ other: ident $($ not_member: ident)*)) => {
                            scope! { @ $ name, $ contains (UpdateTodo $($ member)*) ($ other $($ temp)*) ($($ not_member)*) }
                        };

                        // UpdateTodoStatus match found, pop from both `member` and `not_member`
                        (@ $ name: ident, $ contains: ident (UpdateTodoStatus $($ member: ident)*) ($($ temp: ident)*) (UpdateTodoStatus $($ not_member: ident)*)) => {
                            scope! { @ $ name, $ contains ($($ member)*) ($($ temp)*) ($($ not_member)*) }
                        };
                        // UpdateTodoStatus match not found, pop from `not_member` into `temp` stack
                        (@ $ name: ident, $ contains: ident (UpdateTodoStatus $($ member: ident)*) ($($ temp: ident)*) ($ other: ident $($ not_member: ident)*)) => {
                            scope! { @ $ name, $ contains (UpdateTodoStatus $($ member)*) ($ other $($ temp)*) ($($ not_member)*) }
                        };

                    (
                        $(#[$ attrs:meta])*
                        $ vis:vis struct $ name:ident {
                            includes: [$($ include:ident),*]
                        }
                    ) => {
                        use $ crate::operation_shape::*;
                        ::aws_smithy_http_server::scope! {
                            $(#[$ attrs])*
                            $ vis struct $ name {
                                includes: [$($ include),*],
                                excludes: []
                            }
                        }
                        scope! { @ $ name, False ($($ include)*) () (CreateTodo DeleteTodo EchoMessage GetTodo ListTodos Signin UpdateTodo UpdateTodoStatus) }
                    };
                    (
                        $(#[$ attrs:meta])*
                        $ vis:vis struct $ name:ident {
                            excludes: [$($ exclude:ident),*]
                        }
                    ) => {
                        use $ crate::operation_shape::*;

                        ::aws_smithy_http_server::scope! {
                            $(#[$ attrs])*
                            $ vis struct $ name {
                                includes: [],
                                excludes: [$($ exclude),*]
                            }
                        }
                        scope! { @ $ name, True ($($ exclude)*) () (CreateTodo DeleteTodo EchoMessage GetTodo ListTodos Signin UpdateTodo UpdateTodoStatus) }
                    };
                }
